```sheet
|  ▷▶▷▶ Query 실행 순서 ▷▶▷▶  | < | < | < | < | < | < | < | < | < |
| :----: | :------: | :---------------: | :------: | :------------: | :------: | :---------------: | :------: | :------------: | :------------: |
|  [With](1.%20With)  |   [From](2.%20From%20&%20Join)   |       [Where](3.%20Where%20&%20Group%20By%20&%20Having#^where)       | [Group by](3.%20Where%20&%20Group%20By%20&%20Having#^groupby) |     [Having](3.%20Where%20&%20Group%20By%20&%20Having#^having)     | [Select](4.%20Select) | [Distinct](연산자#^distinct) | [Union / Union all](연산자#^union) | [Order by](5.%20Order%20By%20&%20Offset%20&%20Limit#^orderby) | [Offset](5.%20Order%20By%20&%20Offset%20&%20Limit#^offset) / [Limit](5.%20Order%20By%20&%20Offset%20&%20Limit#^limit) |
```
 - **CTE (Common Table Expression)**
	 - 재사용하기 위한 SubQuery를 임시 Table로 지정하기 위해 사용
	 - With 절로 선언한 Table을 Join 하는 경우 사용하는 Column 명 지정에 주의
	 - Natural Join 시 일치되는 Column 명을 일치(일관) 시켜 출력하기에 더욱 나은 최적화가 가능
```sql
WITH fish_max AS (
	SELECT fish_type, MAX(length) AS max_len
	FROM fish_info
	GROUP BY fish_type
)
SELECT a.id, b.fish_name, a.length
FROM fish_info a
LEFT JOIN fish_max m ON a.fish_type = m.fish_type
LEFT JOIN fish_name_info b ON a.fish_type = b.fish_type
WHERE a.length = m.max_len
ORDER BY a.id ASC;
 -- 수정 전 (Left Join , Where 사용)

 with fish_max as (
	select fish_type, max(length) length 
	from fish_info 
	group by fish_type
)
select a.id, b.fish_name, a.length 
from fish_info a 
natural join fish_max m 
left join fish_name_info b on a.fish_type = b.fish_type 
order by a.id asc
-- 수정 후 (With 선언 Column 명 일치, Natural Join 사용하여 fish_type, length 일치하는 부분만 출력) > 더욱 효율적
 ```
```sql
-- RDBMS (Oracle, MySQL, MS-SQL) 자원사용 입장에서 효율적이지 못해 사용에 주의
/* 1개의 임시테이블 */
WITH 임시테이블 명 AS (
	SUB QUERY 문 (SELECT 절)
)
SELECT 컬럼, [컬럼, ...]
   FROM 임시테이블 명

/* 2개 이상의 임시테이블 */
WITH
임시테이블 명1 AS (
	SUB QUERY 문 (SELECT 절)
),
임시테이블 명2 AS (
	SUB QUERY 문 (SELECT 절)
)
SELECT 컬럼, [컬럼, ...]
   FROM 임시테이블 명1
	  , 임시테이블 명2
```
 - [출처](https://royzero.tistory.com/entry/SQL-WITH%EC%A0%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)

<p></p>

 - **중첩 / 연쇄적 CTE**
	 -  이전 단계에서 정의된 CTE를 참조하여 복잡한 로직 데이터 분리, 데이터 정제에 응용
	 -  서브 쿼리를 사용한 쿼리 보다 가독성 향상, 최적화된 쿼리 설계 가능
	 -  필요한 정보를 최대한으로 호출하여 Join 최소화 (다중 Join = 성능 저하)
	 -  예시 (3중첩 CTE)
		 - 사용 Table submissions , problems
```sql
WITH SolvedLogs AS (
	-- 1. 각 유저가 '맞힌 문제'에 대해 최초 정답 시각과 점수를 먼저 구합니다.
	SELECT 
		s.user_id,
		s.problem_id,
		p.score,
		MIN(s.timestamp) as first_solved_at
	FROM submissions s
	JOIN problems p ON s.problem_id = p.problem_id
	WHERE s.submitted = p.correct_answer
	GROUP BY s.user_id, s.problem_id, p.score
), PenaltyLogs AS (
	-- 2. 위에서 구한 '최초 정답 시각'보다 이전에 제출된 오답 개수를 셉니다.
	SELECT 
		sl.user_id,
		sl.problem_id,
		COUNT(s.timestamp) as wrong_count
	FROM SolvedLogs sl
	JOIN submissions s 
	  ON sl.user_id = s.user_id 
	  AND sl.problem_id = s.problem_id
	WHERE s.timestamp < sl.first_solved_at -- 정답 시각보다 이전 기록
	GROUP BY sl.user_id, sl.problem_id
), UserStats AS (
	-- 3. 점수와 시간을 집계합니다.
	SELECT 
		sl.user_id,
		SUM(sl.score) as total_score,
		-- 걸린 시간 
		-- = (마지막으로 해결한 문제의 시각) + (모든 문제의 페널티 총합 * 300)
		MAX(sl.first_solved_at) 
		+ (COALESCE(SUM(pl.wrong_count), 0) * 300) as time_taken
	FROM SolvedLogs sl
	LEFT JOIN PenaltyLogs pl 
	  ON sl.user_id = pl.user_id 
	  AND sl.problem_id = pl.problem_id
	GROUP BY sl.user_id
)
-- 4. 제출 기록이 있는 모든 유저를 포함하여 최종 출력 (0점 유저 포함)
SELECT 
	u.user_id,
	COALESCE(us.total_score, 0) as total_score,
	COALESCE(us.time_taken, 0) as time_taken
FROM (SELECT DISTINCT user_id FROM submissions) u
LEFT JOIN UserStats us ON u.user_id = us.user_id
ORDER BY total_score DESC, time_taken ASC, user_id ASC;
```

<p></p>

- **재귀 쿼리 (Recursive CTE)**
	- 자기 자신을 참조하여 계층 구조를 탐색하는 CTE
	- 부모 - 자식 (세대) 관계와 같은 계층적 데이터를 다루는데 있어 가장 표준적이고 효율적인 방법
	![[Pasted image 20251224154319.png]]
	 - Date에 Join 하여 행 (Row) 에 번호를 부여하는 재귀 쿼리
```sql
with recursive rc as (
	select 1 as h -- 재귀 초기값
	union all
	select h + 1 -- 재귀
	from rc 
	where h < 5 -- 재귀 정지 조건 ( 1 ~ 5 까지 출력 후 재귀 종료 )
)
select * from rc
   ```
 - 
	 - https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-RECURSIVE-%EC%9E%AC%EA%B7%80-%EC%BF%BC%EB%A6%AC
 - 
	 -  상위 조직의 하위 직원을 연결하는 재귀 쿼리
		 - 작성방법
			 - 앵커 파트에서 기준이 되는 대상을 정의
			 - 재귀 파트에서는 앵커 파트에서 정의된 대상의 반복 옵션을 설정
```sql
With Recursive EmployeeHierarchy AS (
SELECT -- 앵커 파트 정의 : 상위 조직
	employeenumber ,
	firstname ,
	reportsto ,
	CAST(firstname  AS VARCHAR(200)) AS HierarchyPath , 
	-- Cast를 사용하여 데이터형식을 변경 VARCHAR(50) > VARCHAR(200)
	-- 한계를 늘리지 않으면 반복 후 50 bytes 초과 시 ERROR 발생
	0 AS level -- 1세대를 0으로 표기
FROM Employees
WHERE reportsto IS null -- 1세대 지정
UNION ALL -- 두 파트의 Column, 데이터 형식 의 순서와 개수는 동일해야함
SELECT -- 재귀 파트 정의 : 하위 직원 선택
	e.employeenumber ,
	e.firstname ,
	e.reportsto ,
	CAST(eh.HierarchyPath ||' -> '|| e.firstname  AS VARCHAR(200)) AS HierarchyPath ,
	-- 앵커 파트에서 Cast를 사용하였기에 재귀 파트에서도 Cast 사용
	eh.Level + 1 AS Level
FROM Employees e -- 하위 직원
INNER JOIN EmployeeHierarchy eh -- 상위 조직
ON e.reportsto  = eh.employeenumber 
-- 하위 직원 (e) reportsto (상관 번호) 와 상위 조직 (eh) employeenumber (직원 번호) 를 연결
)
SELECT -- 최종 결과 출력
	employeenumber ,
	firstname ,
	reportsto ,
	HierarchyPath ,
	Level
FROM EmployeeHierarchy
ORDER BY HierarchyPath ;
   ```
 - 
	 - https://tak2k.tistory.com/52
	 - https://uminoh.tistory.com/25
		 - 무한 루프 조회시점 방어로직
	- 브래드 크럼스?
		- [https://velog.io/@nayu1105/SQL-%EC%9E%AC%EA%B7%80-%EC%BF%BC%EB%A6%AC](https://velog.io/@nayu1105/SQL-%EC%9E%AC%EA%B7%80-%EC%BF%BC%EB%A6%AC)